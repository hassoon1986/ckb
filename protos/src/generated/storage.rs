// automatically generated by the FlatBuffers compiler, do not modify

use std::cmp::Ordering;
use std::mem;

use super::common::*;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

pub enum StoredBlockOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredBlock<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredBlock<'a> {
    type Inner = StoredBlock<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredBlock<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredBlock { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredBlockArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredBlock<'bldr>> {
        let mut builder = StoredBlockBuilder::new(_fbb);
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;
    pub const VT_CACHE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn data(&self) -> Option<Block<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Block<'a>>>(StoredBlock::VT_DATA, None)
    }
    #[inline]
    pub fn cache(&self) -> Option<StoredBlockCache<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<StoredBlockCache<'a>>>(StoredBlock::VT_CACHE, None)
    }
}

pub struct StoredBlockArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<Block<'a>>>,
    pub cache: Option<flatbuffers::WIPOffset<StoredBlockCache<'a>>>,
}
impl<'a> Default for StoredBlockArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredBlockArgs {
            data: None,
            cache: None,
        }
    }
}
pub struct StoredBlockBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredBlockBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<Block<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Block>>(StoredBlock::VT_DATA, data);
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<StoredBlockCache<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<StoredBlockCache>>(
                StoredBlock::VT_CACHE,
                cache,
            );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StoredBlockBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredBlockBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredBlock<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredBlockCacheOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredBlockCache<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredBlockCache<'a> {
    type Inner = StoredBlockCache<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredBlockCache<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredBlockCache { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredBlockCacheArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredBlockCache<'bldr>> {
        let mut builder = StoredBlockCacheBuilder::new(_fbb);
        if let Some(x) = args.tx_witness_hashes {
            builder.add_tx_witness_hashes(x);
        }
        if let Some(x) = args.tx_hashes {
            builder.add_tx_hashes(x);
        }
        if let Some(x) = args.uncle_hashes {
            builder.add_uncle_hashes(x);
        }
        if let Some(x) = args.header_hash {
            builder.add_header_hash(x);
        }
        builder.finish()
    }

    pub const VT_HEADER_HASH: flatbuffers::VOffsetT = 4;
    pub const VT_UNCLE_HASHES: flatbuffers::VOffsetT = 6;
    pub const VT_TX_HASHES: flatbuffers::VOffsetT = 8;
    pub const VT_TX_WITNESS_HASHES: flatbuffers::VOffsetT = 10;

    #[inline]
    pub fn header_hash(&self) -> Option<&'a Bytes32> {
        self._tab
            .get::<Bytes32>(StoredBlockCache::VT_HEADER_HASH, None)
    }
    #[inline]
    pub fn uncle_hashes(&self) -> Option<&'a [Bytes32]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Bytes32>>>(
                StoredBlockCache::VT_UNCLE_HASHES,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn tx_hashes(&self) -> Option<&'a [Bytes32]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Bytes32>>>(
                StoredBlockCache::VT_TX_HASHES,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn tx_witness_hashes(&self) -> Option<&'a [Bytes32]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Bytes32>>>(
                StoredBlockCache::VT_TX_WITNESS_HASHES,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

pub struct StoredBlockCacheArgs<'a> {
    pub header_hash: Option<&'a Bytes32>,
    pub uncle_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Bytes32>>>,
    pub tx_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Bytes32>>>,
    pub tx_witness_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Bytes32>>>,
}
impl<'a> Default for StoredBlockCacheArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredBlockCacheArgs {
            header_hash: None,
            uncle_hashes: None,
            tx_hashes: None,
            tx_witness_hashes: None,
        }
    }
}
pub struct StoredBlockCacheBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredBlockCacheBuilder<'a, 'b> {
    #[inline]
    pub fn add_header_hash(&mut self, header_hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(StoredBlockCache::VT_HEADER_HASH, header_hash);
    }
    #[inline]
    pub fn add_uncle_hashes(
        &mut self,
        uncle_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Bytes32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            StoredBlockCache::VT_UNCLE_HASHES,
            uncle_hashes,
        );
    }
    #[inline]
    pub fn add_tx_hashes(
        &mut self,
        tx_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Bytes32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            StoredBlockCache::VT_TX_HASHES,
            tx_hashes,
        );
    }
    #[inline]
    pub fn add_tx_witness_hashes(
        &mut self,
        tx_witness_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Bytes32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            StoredBlockCache::VT_TX_WITNESS_HASHES,
            tx_witness_hashes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> StoredBlockCacheBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredBlockCacheBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredBlockCache<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredBlockBodyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredBlockBody<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredBlockBody<'a> {
    type Inner = StoredBlockBody<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredBlockBody<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredBlockBody { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredBlockBodyArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredBlockBody<'bldr>> {
        let mut builder = StoredBlockBodyBuilder::new(_fbb);
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;
    pub const VT_CACHE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn data(&self) -> Option<BlockBody<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<BlockBody<'a>>>(StoredBlockBody::VT_DATA, None)
    }
    #[inline]
    pub fn cache(&self) -> Option<StoredBlockBodyCache<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<StoredBlockBodyCache<'a>>>(
                StoredBlockBody::VT_CACHE,
                None,
            )
    }
}

pub struct StoredBlockBodyArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<BlockBody<'a>>>,
    pub cache: Option<flatbuffers::WIPOffset<StoredBlockBodyCache<'a>>>,
}
impl<'a> Default for StoredBlockBodyArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredBlockBodyArgs {
            data: None,
            cache: None,
        }
    }
}
pub struct StoredBlockBodyBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredBlockBodyBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<BlockBody<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<BlockBody>>(StoredBlockBody::VT_DATA, data);
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<StoredBlockBodyCache<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<StoredBlockBodyCache>>(
                StoredBlockBody::VT_CACHE,
                cache,
            );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StoredBlockBodyBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredBlockBodyBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredBlockBody<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredBlockBodyCacheOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredBlockBodyCache<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredBlockBodyCache<'a> {
    type Inner = StoredBlockBodyCache<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredBlockBodyCache<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredBlockBodyCache { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredBlockBodyCacheArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredBlockBodyCache<'bldr>> {
        let mut builder = StoredBlockBodyCacheBuilder::new(_fbb);
        if let Some(x) = args.tx_witness_hashes {
            builder.add_tx_witness_hashes(x);
        }
        if let Some(x) = args.tx_hashes {
            builder.add_tx_hashes(x);
        }
        builder.finish()
    }

    pub const VT_TX_HASHES: flatbuffers::VOffsetT = 4;
    pub const VT_TX_WITNESS_HASHES: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn tx_hashes(&self) -> Option<&'a [Bytes32]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Bytes32>>>(
                StoredBlockBodyCache::VT_TX_HASHES,
                None,
            )
            .map(|v| v.safe_slice())
    }
    #[inline]
    pub fn tx_witness_hashes(&self) -> Option<&'a [Bytes32]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Bytes32>>>(
                StoredBlockBodyCache::VT_TX_WITNESS_HASHES,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

pub struct StoredBlockBodyCacheArgs<'a> {
    pub tx_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Bytes32>>>,
    pub tx_witness_hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Bytes32>>>,
}
impl<'a> Default for StoredBlockBodyCacheArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredBlockBodyCacheArgs {
            tx_hashes: None,
            tx_witness_hashes: None,
        }
    }
}
pub struct StoredBlockBodyCacheBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredBlockBodyCacheBuilder<'a, 'b> {
    #[inline]
    pub fn add_tx_hashes(
        &mut self,
        tx_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Bytes32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            StoredBlockBodyCache::VT_TX_HASHES,
            tx_hashes,
        );
    }
    #[inline]
    pub fn add_tx_witness_hashes(
        &mut self,
        tx_witness_hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Bytes32>>,
    ) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            StoredBlockBodyCache::VT_TX_WITNESS_HASHES,
            tx_witness_hashes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> StoredBlockBodyCacheBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredBlockBodyCacheBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredBlockBodyCache<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredTransactionInfoOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredTransactionInfo<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredTransactionInfo<'a> {
    type Inner = StoredTransactionInfo<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredTransactionInfo<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredTransactionInfo { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredTransactionInfoArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredTransactionInfo<'bldr>> {
        let mut builder = StoredTransactionInfoBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn data(&self) -> Option<&'a TransactionInfo> {
        self._tab
            .get::<TransactionInfo>(StoredTransactionInfo::VT_DATA, None)
    }
}

pub struct StoredTransactionInfoArgs<'a> {
    pub data: Option<&'a TransactionInfo>,
}
impl<'a> Default for StoredTransactionInfoArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredTransactionInfoArgs { data: None }
    }
}
pub struct StoredTransactionInfoBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredTransactionInfoBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: &'b TransactionInfo) {
        self.fbb_
            .push_slot_always::<&TransactionInfo>(StoredTransactionInfo::VT_DATA, data);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> StoredTransactionInfoBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredTransactionInfoBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredTransactionInfo<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredHeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredHeader<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredHeader<'a> {
    type Inner = StoredHeader<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredHeader<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredHeader { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredHeaderArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredHeader<'bldr>> {
        let mut builder = StoredHeaderBuilder::new(_fbb);
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;
    pub const VT_CACHE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn data(&self) -> Option<Header<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<Header<'a>>>(StoredHeader::VT_DATA, None)
    }
    #[inline]
    pub fn cache(&self) -> Option<StoredHeaderCache<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<StoredHeaderCache<'a>>>(
                StoredHeader::VT_CACHE,
                None,
            )
    }
}

pub struct StoredHeaderArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<Header<'a>>>,
    pub cache: Option<flatbuffers::WIPOffset<StoredHeaderCache<'a>>>,
}
impl<'a> Default for StoredHeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredHeaderArgs {
            data: None,
            cache: None,
        }
    }
}
pub struct StoredHeaderBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredHeaderBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: flatbuffers::WIPOffset<Header<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<Header>>(StoredHeader::VT_DATA, data);
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<StoredHeaderCache<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<StoredHeaderCache>>(
                StoredHeader::VT_CACHE,
                cache,
            );
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StoredHeaderBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredHeaderBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredHeader<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredTipOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredTip<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredTip<'a> {
    type Inner = StoredTip<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredTip<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredTip { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredTipArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredTip<'bldr>> {
        let mut builder = StoredTipBuilder::new(_fbb);
        if let Some(x) = args.total_difficulty {
            builder.add_total_difficulty(x);
        }
        if let Some(x) = args.header {
            builder.add_header(x);
        }
        builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_TOTAL_DIFFICULTY: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn header(&self) -> Option<StoredHeader<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<StoredHeader<'a>>>(StoredTip::VT_HEADER, None)
    }
    #[inline]
    pub fn total_difficulty(&self) -> Option<&'a Bytes32> {
        self._tab
            .get::<Bytes32>(StoredTip::VT_TOTAL_DIFFICULTY, None)
    }
}

pub struct StoredTipArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<StoredHeader<'a>>>,
    pub total_difficulty: Option<&'a Bytes32>,
}
impl<'a> Default for StoredTipArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredTipArgs {
            header: None,
            total_difficulty: None,
        }
    }
}
pub struct StoredTipBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredTipBuilder<'a, 'b> {
    #[inline]
    pub fn add_header(&mut self, header: flatbuffers::WIPOffset<StoredHeader<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<StoredHeader>>(StoredTip::VT_HEADER, header);
    }
    #[inline]
    pub fn add_total_difficulty(&mut self, total_difficulty: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(StoredTip::VT_TOTAL_DIFFICULTY, total_difficulty);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StoredTipBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredTipBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredTip<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredHeaderCacheOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredHeaderCache<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredHeaderCache<'a> {
    type Inner = StoredHeaderCache<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredHeaderCache<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredHeaderCache { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredHeaderCacheArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredHeaderCache<'bldr>> {
        let mut builder = StoredHeaderCacheBuilder::new(_fbb);
        if let Some(x) = args.hash {
            builder.add_hash(x);
        }
        builder.finish()
    }

    pub const VT_HASH: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn hash(&self) -> Option<&'a Bytes32> {
        self._tab.get::<Bytes32>(StoredHeaderCache::VT_HASH, None)
    }
}

pub struct StoredHeaderCacheArgs<'a> {
    pub hash: Option<&'a Bytes32>,
}
impl<'a> Default for StoredHeaderCacheArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredHeaderCacheArgs { hash: None }
    }
}
pub struct StoredHeaderCacheBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredHeaderCacheBuilder<'a, 'b> {
    #[inline]
    pub fn add_hash(&mut self, hash: &'b Bytes32) {
        self.fbb_
            .push_slot_always::<&Bytes32>(StoredHeaderCache::VT_HASH, hash);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> StoredHeaderCacheBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredHeaderCacheBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredHeaderCache<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredUncleBlocksOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredUncleBlocks<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredUncleBlocks<'a> {
    type Inner = StoredUncleBlocks<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredUncleBlocks<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredUncleBlocks { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredUncleBlocksArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredUncleBlocks<'bldr>> {
        let mut builder = StoredUncleBlocksBuilder::new(_fbb);
        if let Some(x) = args.cache {
            builder.add_cache(x);
        }
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;
    pub const VT_CACHE: flatbuffers::VOffsetT = 6;

    #[inline]
    pub fn data(
        &self,
    ) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UncleBlock<'a>>>> {
        self._tab.get::<flatbuffers::ForwardsUOffset<
            flatbuffers::Vector<flatbuffers::ForwardsUOffset<UncleBlock<'a>>>,
        >>(StoredUncleBlocks::VT_DATA, None)
    }
    #[inline]
    pub fn cache(&self) -> Option<StoredUncleBlocksCache<'a>> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<StoredUncleBlocksCache<'a>>>(
                StoredUncleBlocks::VT_CACHE,
                None,
            )
    }
}

pub struct StoredUncleBlocksArgs<'a> {
    pub data: Option<
        flatbuffers::WIPOffset<
            flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<UncleBlock<'a>>>,
        >,
    >,
    pub cache: Option<flatbuffers::WIPOffset<StoredUncleBlocksCache<'a>>>,
}
impl<'a> Default for StoredUncleBlocksArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredUncleBlocksArgs {
            data: None,
            cache: None,
        }
    }
}
pub struct StoredUncleBlocksBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredUncleBlocksBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(
        &mut self,
        data: flatbuffers::WIPOffset<
            flatbuffers::Vector<'b, flatbuffers::ForwardsUOffset<UncleBlock<'b>>>,
        >,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(StoredUncleBlocks::VT_DATA, data);
    }
    #[inline]
    pub fn add_cache(&mut self, cache: flatbuffers::WIPOffset<StoredUncleBlocksCache<'b>>) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<StoredUncleBlocksCache>>(
                StoredUncleBlocks::VT_CACHE,
                cache,
            );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> StoredUncleBlocksBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredUncleBlocksBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredUncleBlocks<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredUncleBlocksCacheOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredUncleBlocksCache<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredUncleBlocksCache<'a> {
    type Inner = StoredUncleBlocksCache<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredUncleBlocksCache<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredUncleBlocksCache { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredUncleBlocksCacheArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredUncleBlocksCache<'bldr>> {
        let mut builder = StoredUncleBlocksCacheBuilder::new(_fbb);
        if let Some(x) = args.hashes {
            builder.add_hashes(x);
        }
        builder.finish()
    }

    pub const VT_HASHES: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn hashes(&self) -> Option<&'a [Bytes32]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Bytes32>>>(
                StoredUncleBlocksCache::VT_HASHES,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

pub struct StoredUncleBlocksCacheArgs<'a> {
    pub hashes: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, Bytes32>>>,
}
impl<'a> Default for StoredUncleBlocksCacheArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredUncleBlocksCacheArgs { hashes: None }
    }
}
pub struct StoredUncleBlocksCacheBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredUncleBlocksCacheBuilder<'a, 'b> {
    #[inline]
    pub fn add_hashes(&mut self, hashes: flatbuffers::WIPOffset<flatbuffers::Vector<'b, Bytes32>>) {
        self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
            StoredUncleBlocksCache::VT_HASHES,
            hashes,
        );
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> StoredUncleBlocksCacheBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredUncleBlocksCacheBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredUncleBlocksCache<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredProposalShortIdsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredProposalShortIds<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredProposalShortIds<'a> {
    type Inner = StoredProposalShortIds<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredProposalShortIds<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredProposalShortIds { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredProposalShortIdsArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredProposalShortIds<'bldr>> {
        let mut builder = StoredProposalShortIdsBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn data(&self) -> Option<&'a [ProposalShortId]> {
        self._tab
            .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<ProposalShortId>>>(
                StoredProposalShortIds::VT_DATA,
                None,
            )
            .map(|v| v.safe_slice())
    }
}

pub struct StoredProposalShortIdsArgs<'a> {
    pub data: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, ProposalShortId>>>,
}
impl<'a> Default for StoredProposalShortIdsArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredProposalShortIdsArgs { data: None }
    }
}
pub struct StoredProposalShortIdsBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredProposalShortIdsBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(
        &mut self,
        data: flatbuffers::WIPOffset<flatbuffers::Vector<'b, ProposalShortId>>,
    ) {
        self.fbb_
            .push_slot_always::<flatbuffers::WIPOffset<_>>(StoredProposalShortIds::VT_DATA, data);
    }
    #[inline]
    pub fn new(
        _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    ) -> StoredProposalShortIdsBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredProposalShortIdsBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredProposalShortIds<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredEpochExtOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredEpochExt<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredEpochExt<'a> {
    type Inner = StoredEpochExt<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredEpochExt<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredEpochExt { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredEpochExtArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredEpochExt<'bldr>> {
        let mut builder = StoredEpochExtBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn data(&self) -> Option<&'a EpochExt> {
        self._tab.get::<EpochExt>(StoredEpochExt::VT_DATA, None)
    }
}

pub struct StoredEpochExtArgs<'a> {
    pub data: Option<&'a EpochExt>,
}
impl<'a> Default for StoredEpochExtArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredEpochExtArgs { data: None }
    }
}
pub struct StoredEpochExtBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredEpochExtBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: &'b EpochExt) {
        self.fbb_
            .push_slot_always::<&EpochExt>(StoredEpochExt::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StoredEpochExtBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredEpochExtBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredEpochExt<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}

pub enum StoredCellMetaOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StoredCellMeta<'a> {
    pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StoredCellMeta<'a> {
    type Inner = StoredCellMeta<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StoredCellMeta<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StoredCellMeta { _tab: table }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StoredCellMetaArgs<'args>,
    ) -> flatbuffers::WIPOffset<StoredCellMeta<'bldr>> {
        let mut builder = StoredCellMetaBuilder::new(_fbb);
        if let Some(x) = args.data {
            builder.add_data(x);
        }
        builder.finish()
    }

    pub const VT_DATA: flatbuffers::VOffsetT = 4;

    #[inline]
    pub fn data(&self) -> Option<&'a CellMeta> {
        self._tab.get::<CellMeta>(StoredCellMeta::VT_DATA, None)
    }
}

pub struct StoredCellMetaArgs<'a> {
    pub data: Option<&'a CellMeta>,
}
impl<'a> Default for StoredCellMetaArgs<'a> {
    #[inline]
    fn default() -> Self {
        StoredCellMetaArgs { data: None }
    }
}
pub struct StoredCellMetaBuilder<'a: 'b, 'b> {
    fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StoredCellMetaBuilder<'a, 'b> {
    #[inline]
    pub fn add_data(&mut self, data: &'b CellMeta) {
        self.fbb_
            .push_slot_always::<&CellMeta>(StoredCellMeta::VT_DATA, data);
    }
    #[inline]
    pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StoredCellMetaBuilder<'a, 'b> {
        let start = _fbb.start_table();
        StoredCellMetaBuilder {
            fbb_: _fbb,
            start_: start,
        }
    }
    #[inline]
    pub fn finish(self) -> flatbuffers::WIPOffset<StoredCellMeta<'a>> {
        let o = self.fbb_.end_table(self.start_);
        flatbuffers::WIPOffset::new(o.value())
    }
}
